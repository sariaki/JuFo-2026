\section{Ansatz} 
\subsection{Angreifermodell}
Diese Arbeit geht aufgrund der Ähnlichkeit behandelter Thematik von einem ähnlichen Angreifermodell wie \cite{xuManufacturingResilientBiOpaque2018} aus.
Ein Angreifer hat direkten Zugriff auf das Programm und dessen Anweisungen. Es sei dem Angreifer hierbei nicht vorgegeben, wo und inwiefern das Programm obfuskiert ist. Der Angreifer kann das Programm nur statisch mittels symbolischer Ausführung sowie durch Untersuchung der Programmanweisungen analysieren und nicht ausführen. Solchen Situationen begegnet man z.B. bei Malware oder bei Software, welche für proprietäre unverfügbare Systeme geschrieben ist.
Eine Härtung gegen weitere (dynamische) Analysemethoden des Angreifers wird in \cref{sec:fazit} diskutiert.
\subsection{Algorithmus}
Während andere präsentierte Ansätze auf schweren Problemen beruhen, welche gelöst werden müsse, um einen Pfad auszuschließen, macht dieser Algorithmus dieses Ausschließen mit herkömmlichen Methoden unmöglich. Hierfür wird mit Wahrscheinlichkeit gearbeitet. Für jedes zu generierendes opakes Prädikat wird im Programm ein Pseudozufallsvariable $x$ generiert. Verschiedene Methoden hierfür werden in \cref{sec:pseudoZufall} gegeben. Wichtig ist, dass der Angreifer den Wert von $x$ nicht statisch bestimmen kann. Es wird angenommen, dass $x$ uniform verteilt ist. Diese Verteilung wird nun in eine andere (z.B. Normal-, Exponential-, Bernoulliverteilung) transformiert. 

Der Pseudocode hierfür ist in \cref{alg:stochasticOpaque} beschreiben.
\begin{algorithm}[!htb] 
    \caption{Generierung stochastischer opaker Prädikate}
    \label{alg:stochasticOpaque}
    \begin{algorithmic}[1]

    \State Erstelle Funktion $\mathit{TransformiereVerteilung}(x)$ im Modul, welche uniform verteilte Variable $x\in\space ]0; 1]$ normal verteilt. \\
    
    \Procedure{FügePrädikatEin}{$\mathit{Modul, T}$}
    \ForAll{Funktion in Modul}
        \State $BasisBlock \gets \Call{ZufälligerBasisBlock}{\mathit{Funktion}}$
        \State $\mathit{Entry} \gets \Call{ZufälligeAnweisung}{\mathit{BasisBlock}}$
        %\State $\mathit{LebendeVariable} \gets \Call{ZufälligeLebendeVariable}{\mathit{Entry}}$ \\
        \State $\mathit{ZufaelligerWert} \gets \Call{ErstelleFunktionsAufruf}{\mathit{UniformeVerteilung}, ]0; 1]}$ \\
        
        \State $\mathit{TransformierteVariable} \gets \Call{ErstelleFunktionsAufruf}{\mathit{TransformiereVerteilung, ZufaelligerWert}}$
        \State $\Call{ErstelleVergleich}{\mathit{TransformierteVariable}}$ \\
        
        \State $BB_{\mathrm{immer\_wahr}} \gets \Call{Splitblock}{\mathit{BasisBlock, Entry}}$
        \Comment{Basisblöcke für Prädikatenfälle generieren}
        \State $BB_{\mathrm{nie\_wahr}} \gets \Call{NeuerBlock}{\mathit{Funktion}}$ \\
    
        \State $\Call{ErstelleBedingteVerzweigung}{"\mathit{TransformierteVariable \geq T}", BB_{\mathrm{immer\_wahr}}, BB_{\mathrm{nie\_wahr}}}$ \\

        \State Fülle Basisblock $BB_{\mathrm{nie\_wahr}}$ mit zufälligen Anweisungen.
    \EndFor
    \EndProcedure
    \end{algorithmic}
\end{algorithm}
\subsection{Experimente}
\subsubsection{Optimale Wahrscheinlichkeitsverteilung}
